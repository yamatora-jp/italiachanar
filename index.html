<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Babylon.js + AR.js Marker AR</title>

  <!-- Babylon.js -->
  <script src="https://cdn.babylonjs.com/babylon.js"></script>

  <!-- AR.js Babylon.js binding -->
  <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js/aframe/examples/babylon/aframe-babylon.js"></script>
</head>
<body style="margin: 0; overflow: hidden;">
  <canvas id="renderCanvas"></canvas>

  <script>
    const canvas = document.getElementById("renderCanvas");
    const engine = new BABYLON.Engine(canvas, true);
    const scene = new BABYLON.Scene(engine);

    // ã‚«ãƒ¡ãƒ©ã¯ AR.js ãŒåˆ¶å¾¡
    const camera = new BABYLON.Camera("camera", scene);

    // ãƒ©ã‚¤ãƒˆ
    new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);

    // ãƒãƒ¼ã‚«ãƒ¼ root
    const markerRoot = new BABYLON.TransformNode("markerRoot", scene);

    // ğŸ”¹ PLYç‚¹ç¾¤ã‚’èª­ã¿è¾¼ã‚€é–¢æ•°
    async function loadColoredPLY(url) {
      const response = await fetch(url);
      const text = await response.text();

      const lines = text.split("\n");
      let inHeader = true;
      let vertices = [];

      for (let line of lines) {
        if (inHeader) {
          if (line.startsWith("end_header")) {
            inHeader = false;
          }
        } else {
          if (line.trim().length === 0) continue;
          const parts = line.trim().split(/\s+/).map(Number);
          if (parts.length >= 6) {
            vertices.push({
              position: new BABYLON.Vector3(parts[0], parts[1], parts[2]),
              color: new BABYLON.Color4(parts[3] / 255, parts[4] / 255, parts[5] / 255, 1.0),
            });
          }
        }
      }

      const pcs = new BABYLON.PointsCloudSystem("pcs", { capacity: vertices.length }, scene);
      vertices.forEach(v => {
        pcs.addParticle({
          positionFunction: (p) => {
            p.position = v.position;
            p.color = v.color;
          }
        });
      });
      await pcs.buildMeshAsync();
      pcs.mesh.scaling = new BABYLON.Vector3(0.01, 0.01, 0.01);
      return pcs.mesh;
    }

    // ğŸ”¹ PLYãƒ¢ãƒ‡ãƒ«ã‚’ãƒ­ãƒ¼ãƒ‰ã—ã¦ãƒãƒ¼ã‚«ãƒ¼ã«è¿½åŠ 
    loadColoredPLY("./gs_italiachan.splat").then(mesh => {
      mesh.parent = markerRoot;
    });

    // AR.js Babylon åˆæœŸåŒ–
    const arToolkit = new ARjsBabylon(engine, scene, camera, {
      sourceType: 'webcam',
      detectionMode: 'mono',
      matrixCodeType: '3x3',
    });

    // Hiroãƒãƒ¼ã‚«ãƒ¼æ¤œå‡º
    arToolkit.addMarker(markerRoot, {
      type: 'pattern',
      patternUrl: 'https://cdn.jsdelivr.net/gh/AR-js-org/AR.js/aframe/examples/marker-training/examples/pattern-files/pattern-hiro.patt',
    });

    // ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ãƒ«ãƒ¼ãƒ—
    engine.runRenderLoop(() => {
      scene.render();
    });
  </script>
</body>
</html>
