<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Babylon.js + AR.js Marker AR</title>

  <!-- Babylon.js -->
  <script src="https://cdn.babylonjs.com/babylon.js"></script>

  <!-- AR.js for Babylon.js -->
  <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js/aframe/examples/babylon/aframe-babylon.js"></script>
  <!--  <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/examples/babylon/babylon.js"></script> -->
</head>
<body style="margin: 0; overflow: hidden;">
  <canvas id="renderCanvas"></canvas>

  <script>
    // Babylon.js ã‚¨ãƒ³ã‚¸ãƒ³
    const canvas = document.getElementById("renderCanvas");
    const engine = new BABYLON.Engine(canvas, true);

    // ã‚·ãƒ¼ãƒ³ä½œæˆ
    const scene = new BABYLON.Scene(engine);

    // ã‚«ãƒ¡ãƒ© (AR.js ãŒåˆ¶å¾¡)
    const camera = new BABYLON.FreeCamera("camera", new BABYLON.Vector3(0, 0, 0), scene);

    // ãƒ©ã‚¤ãƒˆ
    const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);

    // ðŸ”¹ PLYç‚¹ç¾¤ã‚’èª­ã¿è¾¼ã¿
    async function loadColoredPLY(url) {
      const response = await fetch(url);
      const text = await response.text();

      const lines = text.split("\n");
      let inHeader = true;
      let vertices = [];

      for (let line of lines) {
        if (inHeader) {
          if (line.startsWith("end_header")) {
            inHeader = false;
          }
        } else {
          if (line.trim().length === 0) continue;
          const parts = line.trim().split(/\s+/).map(Number);
          if (parts.length >= 6) {
            vertices.push({
              position: new BABYLON.Vector3(parts[0], parts[1], parts[2]),
              color: new BABYLON.Color4(parts[3] / 255, parts[4] / 255, parts[5] / 255, 1.0),
            });
          }
        }
      }

      const pcs = new BABYLON.PointsCloudSystem("pcs", { capacity: vertices.length }, scene);
      vertices.forEach(v => {
        pcs.addParticle({
          positionFunction: (p) => {
            p.position = v.position;
            p.color = v.color;
          }
        });
      });
      await pcs.buildMeshAsync();
      pcs.mesh.scaling = new BABYLON.Vector3(0.01, 0.01, 0.01);
      return pcs.mesh;
    }

    // ãƒžãƒ¼ã‚«ãƒ¼ã«ã‚¢ã‚¿ãƒƒãƒã•ã‚Œã‚‹ã‚°ãƒ«ãƒ¼ãƒ—
    const markerRoot = new BABYLON.TransformNode("markerRoot", scene);

    // PLYãƒ¢ãƒ‡ãƒ«ã‚’ãƒ­ãƒ¼ãƒ‰ã—ã¦ãƒžãƒ¼ã‚«ãƒ¼ã«ä¹—ã›ã‚‹
    loadColoredPLY("./gs_italiachan.splat").then(mesh => {
      mesh.parent = markerRoot;
    });

    // AR.js ã‚«ãƒ¡ãƒ©è¨­å®š
    const arToolkitSource = new THREEx.ArToolkitSource({ sourceType: 'webcam' });
    const arToolkitContext = new THREEx.ArToolkitContext({ cameraParametersUrl: 'https://cdn.jsdelivr.net/gh/AR-js-org/AR.js/aframe/examples/marker-training/examples/marker-training/examples/camera_para.dat' });

    // åˆæœŸåŒ–
    arToolkitSource.init(() => {
      setTimeout(() => {
        arToolkitContext.arController.init(function onCompleted() {
          camera.projectionMatrix.fromArray(arToolkitContext.getProjectionMatrix());
        });
      }, 2000);
    });

    // ãƒžãƒ¼ã‚«ãƒ¼ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«
    const markerControls = new THREEx.ArMarkerControls(arToolkitContext, markerRoot, {
      type: 'pattern',
      patternUrl: 'https://cdn.jsdelivr.net/gh/AR-js-org/AR.js/aframe/examples/marker-training/examples/pattern-files/pattern-hiro.patt',
    });

    // ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ãƒ«ãƒ¼ãƒ—
    engine.runRenderLoop(() => {
      if (arToolkitSource.ready) {
        arToolkitContext.update(arToolkitSource.domElement);
      }
      scene.render();
    });
  </script>
</body>
</html>
