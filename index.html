<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Babylon.js + MindAR PLY Gaussian Splatting</title>
  <!-- Babylon.js -->
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <!-- MindAR (Image Tracking) -->
  <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-three.prod.js"></script>
  <style>
    body, html { margin: 0; padding: 0; overflow: hidden; }
    #ar-container { width: 100vw; height: 100vh; }
  </style>
</head>
<body>
  <div id="ar-container"></div>

  <script>
    // ðŸ”¹ PLY èª­ã¿è¾¼ã¿ï¼ˆASCIIå½¢å¼ã€XYZRGBå¯¾å¿œï¼‰
    async function loadColoredPLY(scene, url) {
      const response = await fetch(url);
      const text = await response.text();

      const lines = text.split("\n");
      let inHeader = true;
      let vertices = [];
      let vertexCount = 0;

      for (let line of lines) {
        if (inHeader) {
          if (line.startsWith("element vertex")) {
            vertexCount = parseInt(line.split(" ")[2]);
          }
          if (line.startsWith("end_header")) {
            inHeader = false;
          }
        } else {
          if (line.trim().length === 0) continue;
          const parts = line.trim().split(/\s+/).map(Number);
          if (parts.length >= 6) {
            vertices.push({
              position: new BABYLON.Vector3(parts[0], parts[1], parts[2]),
              color: new BABYLON.Color4(parts[3] / 255, parts[4] / 255, parts[5] / 255, 1.0),
            });
          }
        }
      }

      // PointCloudSystem (PCS)
      const pcs = new BABYLON.PointsCloudSystem("pcs", { capacity: vertices.length }, scene);

      vertices.forEach(v => {
        pcs.addParticle({
          positionFunction: (p) => {
            p.position = v.position;
            p.color = v.color;
          }
        });
      });

      await pcs.buildMeshAsync();
      pcs.mesh.scaling = new BABYLON.Vector3(0.01, 0.01, 0.01); // ã‚µã‚¤ã‚ºèª¿æ•´
      return pcs.mesh;
    }

    document.addEventListener("DOMContentLoaded", async () => {
      // MindARã®æº–å‚™
      const mindarThree = new window.MINDAR.IMAGE.MindARThree({
        container: document.querySelector("#ar-container"),
        imageTargetSrc: "./marker.mind", // ã“ã“ã«ãƒžãƒ¼ã‚«ãƒ¼å®šç¾©ãƒ•ã‚¡ã‚¤ãƒ«
      });

      const {renderer, scene, camera} = mindarThree;

      // Babylon.js ã‚¨ãƒ³ã‚¸ãƒ³ã‚’ MindAR ã® canvas ä¸Šã«æ§‹ç¯‰
      const engine = new BABYLON.Engine(renderer.domElement, true);
      const babylonScene = new BABYLON.Scene(engine);

      // ã‚«ãƒ¡ãƒ©ã¨å…‰æº
      const babylonCamera = new BABYLON.FreeCamera("camera", new BABYLON.Vector3(0, 0, -10), babylonScene);
      const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), babylonScene);

      // ðŸ”¹ PLYç‚¹ç¾¤ã‚’èª­ã¿è¾¼ã¿
      const pcsMesh = await loadColoredPLY(babylonScene, "./gs_italiachan_ascii.ply");

      // ðŸ”¹ ARãƒžãƒ¼ã‚«ãƒ¼ã«é–¢é€£ä»˜ã‘
      const anchor = mindarThree.addAnchor(0); // 0 = æœ€åˆã®ãƒžãƒ¼ã‚«ãƒ¼
      anchor.group.add(pcsMesh);

      // ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ãƒ«ãƒ¼ãƒ—
      engine.runRenderLoop(() => {
        babylonScene.render();
      });

      // MindARé–‹å§‹
      await mindarThree.start();
    });
  </script>
</body>
</html>
